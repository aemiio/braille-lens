package com.aemiio.braillelens.ui.screens

import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.graphics.Paint
import android.net.Uri
import android.util.Log
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.gestures.detectDragGestures
import androidx.compose.foundation.gestures.detectTapGestures
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material.icons.filled.Edit
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.geometry.Size
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.asImageBitmap
import androidx.compose.ui.graphics.drawscope.Stroke
import androidx.compose.ui.graphics.nativeCanvas
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalDensity
import androidx.compose.ui.unit.dp
import androidx.navigation.NavController
import com.aemiio.braillelens.objectdetection.BrailleMap
import com.aemiio.braillelens.services.ObjectDetectionService
import com.aemiio.braillelens.ui.BrailleLensColors
import com.aemiio.braillelens.utils.*
import org.json.JSONArray
import kotlin.math.abs
import com.aemiio.braillelens.R
import com.aemiio.braillelens.objectdetection.BrailleClassIdMapper

enum class AnnotationMode {
    VIEW, ADD, EDIT, DELETE
}

// Helper class from AnnotationsUtils.kt
enum class ResizeHandle {
    TOP, RIGHT, BOTTOM, LEFT,
    TOP_LEFT, TOP_RIGHT,
    BOTTOM_LEFT, BOTTOM_RIGHT,
    NONE
}

data class DetectedBox(
    var x: Float,
    var y: Float,
    var width: Float,
    var height: Float,
    var className: String,  // Storing meaning
    var classId: Int
)

data class AnnotationStyle(
    val boxColors: Map<AnnotationMode, Color> = mapOf(
        AnnotationMode.VIEW to Color.Green,
        AnnotationMode.EDIT to Color.Red,
        AnnotationMode.ADD to Color.Blue,
        AnnotationMode.DELETE to Color.Red
    ),
    val strokeWidth: Map<AnnotationMode, Float> = mapOf(
        AnnotationMode.VIEW to 2f,
        AnnotationMode.EDIT to 3f,
        AnnotationMode.ADD to 2f,
        AnnotationMode.DELETE to 2f
    )
)

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun AnnotationScreen(
    navController: NavController,
    imagePath: String,
    detectionResult: String?,
    model: String? = "Grade 1 Braille"
) {
    val context = LocalContext.current
    val coroutineScope = rememberCoroutineScope()
    val scrollState = rememberScrollState()
    val objectDetectionService = remember { ObjectDetectionService() }

    // State variables
    var originalBitmap by remember { mutableStateOf<Bitmap?>(null) }
    val boxes = remember { mutableStateListOf<DetectedBox>() }
    var currentMode by remember { mutableStateOf(AnnotationMode.VIEW) }
    var selectedBox by remember { mutableStateOf<Int?>(null) }
    var isDrawing by remember { mutableStateOf(false) }
    var startPoint by remember { mutableStateOf(Offset.Zero) }
    var endPoint by remember { mutableStateOf(Offset.Zero) }
    var classSelectionOpen by remember { mutableStateOf(false) }
    var currentClass by remember { mutableStateOf("A") }
    var gradeSelected by remember { mutableStateOf(model?.replace(" Braille", "") ?: "Grade 1") }
    var isLoading by remember { mutableStateOf(true) }
    var snackbarMessage by remember { mutableStateOf<String?>(null) }
    val snackbarHostState = remember { SnackbarHostState() }
    val annotationStyle = remember { AnnotationStyle() }

    // Get class options based on grade
    val classOptions = remember(gradeSelected) {
        when (gradeSelected) {
            "Grade 1" -> BrailleMap.G1brailleMap.values.map { it.meaning }.sorted()
            "Grade 2" -> BrailleMap.G2brailleMap.values.map { it.meaning }.sorted()
            "Both" -> BrailleMap.G1brailleMap.values.map { it.meaning }.sorted() +
                    BrailleMap.G2brailleMap.values.map { it.meaning }.sorted().distinct()
            else -> BrailleMap.G1brailleMap.values.map { it.meaning }.sorted()
        }
    }

    // Process the image
    LaunchedEffect(imagePath) {
        try {
            isLoading = true

            // Load the image bitmap
            if (imagePath.startsWith("file:") || imagePath.startsWith("content:")) {
                val uri = Uri.parse(imagePath)
                val inputStream = context.contentResolver.openInputStream(uri)
                originalBitmap = BitmapFactory.decodeStream(inputStream)
                inputStream?.close()
            } else {
                // Handle sample images or resource IDs
                try {
                    val resourceId = imagePath.toInt()
                    originalBitmap = BitmapFactory.decodeResource(context.resources, resourceId)
                } catch (e: NumberFormatException) {
                    // Default to a sample image
                    originalBitmap = BitmapFactory.decodeResource(
                        context.resources,
                        R.drawable.sample1
                    )
                }
            }

            // If we have detection results, parse them
            if (!detectionResult.isNullOrEmpty()) {
                try {
                    val parts = detectionResult.split("|")
                    parts.forEach { part ->
                        val values = part.split(",")
                        if (values.size >= 5) {
                            boxes.add(
                                DetectedBox(
                                    x = values[0].toFloat(),
                                    y = values[1].toFloat(),
                                    width = values[2].toFloat(),
                                    height = values[3].toFloat(),
                                    classId = values[4].toInt(),
                                    className = values[5] // Now storing meaning directly
                                )
                            )
                        }
                    }
                } catch (e: Exception) {
                    Log.e("AnnotationScreen", "Error parsing detection results", e)
                    snackbarMessage = "Error parsing detection results"
                }
            }
        } catch (e: Exception) {
            Log.e("AnnotationScreen", "Error loading image", e)
            snackbarMessage = "Error loading image: ${e.message}"
        } finally {
            isLoading = false
        }
    }

    // Snackbar handling
    LaunchedEffect(snackbarMessage) {
        snackbarMessage?.let {
            snackbarHostState.showSnackbar(it)
            snackbarMessage = null
        }
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Annotation Editor - $model") },
                navigationIcon = {
                    IconButton(onClick = { navController.popBackStack() }) {
                        Icon(
                            imageVector = Icons.AutoMirrored.Filled.ArrowBack,
                            contentDescription = "Back"
                        )
                    }
                }
            )
        },
        snackbarHost = { SnackbarHost(snackbarHostState) }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .padding(paddingValues)
                .padding(16.dp)
                .verticalScroll(scrollState),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            // Mode selection buttons
            ModeSelectionButtons(
                currentMode = currentMode,
                onModeChange = {
                    currentMode = it
                    selectedBox = null
                }
            )

            // Grade and class selector
            if (currentMode == AnnotationMode.ADD ||
                (currentMode == AnnotationMode.EDIT && selectedBox != null)) {
                GradeAndClassSelector(
                    gradeSelected = gradeSelected,
                    onGradeChange = { gradeSelected = it },
                    classOptions = classOptions,
                    selectedBox = selectedBox,
                    boxes = boxes,
                    currentClass = currentClass,
                    onClassChange = { newClass ->
                        if (currentMode == AnnotationMode.EDIT && selectedBox != null) {
                            boxes[selectedBox!!] = boxes[selectedBox!!].copy(className = newClass)
                        } else {
                            currentClass = newClass
                        }
                    }
                )
            }

            // Canvas for drawing boxes
            originalBitmap?.let { bitmap ->
                AnnotationCanvas(
                    bitmap = bitmap,
                    boxes = boxes,
                    selectedBox = selectedBox,
                    currentMode = currentMode,
                    isDrawing = isDrawing,
                    startPoint = startPoint,
                    endPoint = endPoint,
                    currentClass = currentClass,
                    onIsDrawingChange = { isDrawing = it },
                    onStartPointChange = { startPoint = it },
                    onEndPointChange = { endPoint = it },
                    onBoxAdd = { box ->
                        boxes.add(box)
                    },
                    onBoxDelete = { index ->
                        boxes.removeAt(index)
                        selectedBox = null
                    },
                    onBoxSelect = { selectedBox = it },
                    onBoxUpdate = { index, updatedBox ->
                        boxes[index] = updatedBox
                    },
                    annotationStyle = annotationStyle
                )
            }

            // Box edit controls
            if (currentMode == AnnotationMode.EDIT && selectedBox != null) {
                BoxEditControls(
                    box = boxes[selectedBox!!],
                    onBoxUpdate = { updatedBox ->
                        boxes[selectedBox!!] = validateAndNormalizeBox(updatedBox)
                    }
                )
            }

            // Save button
            if (!isLoading) {
                SaveAnnotationsButton(
                    boxes = boxes,
                    imagePath = imagePath,
                    bitmap = originalBitmap,
                    grade = gradeSelected,
                    onSaveStart = {
                        isLoading = true
                        snackbarMessage = "Saving annotations..."
                    },
                    onSaveComplete = { success, message ->
                        isLoading = false
                        snackbarMessage = message
                        if (success) {
                            navController.popBackStack()
                        }
                    }
                )
            }
        }
    }
}

@Composable
private fun ModeSelectionButtons(
    currentMode: AnnotationMode,
    onModeChange: (AnnotationMode) -> Unit
) {
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .padding(vertical = 8.dp),
        horizontalArrangement = Arrangement.SpaceEvenly
    ) {
        Button(
            onClick = { onModeChange(AnnotationMode.VIEW) },
            colors = ButtonDefaults.buttonColors(
                containerColor = if (currentMode == AnnotationMode.VIEW)
                    BrailleLensColors.darkOlive else BrailleLensColors.pastelGreen
            ),
            modifier = Modifier.weight(1f)
        ) {
            Text("View")
        }
        Spacer(modifier = Modifier.width(8.dp))
        Button(
            onClick = { onModeChange(AnnotationMode.ADD) },
            colors = ButtonDefaults.buttonColors(
                containerColor = if (currentMode == AnnotationMode.ADD)
                    BrailleLensColors.darkOlive else BrailleLensColors.pastelGreen
            ),
            modifier = Modifier.weight(1f)
        ) {
            Icon(Icons.Default.Add, contentDescription = "Add")
            Text("Add")
        }
        Spacer(modifier = Modifier.width(8.dp))
        Button(
            onClick = { onModeChange(AnnotationMode.EDIT) },
            colors = ButtonDefaults.buttonColors(
                containerColor = if (currentMode == AnnotationMode.EDIT)
                    BrailleLensColors.darkOlive else BrailleLensColors.pastelGreen
            ),
            modifier = Modifier.weight(1f)
        ) {
            Icon(Icons.Default.Edit, contentDescription = "Edit")
            Text("Edit")
        }
        Spacer(modifier = Modifier.width(8.dp))
        Button(
            onClick = { onModeChange(AnnotationMode.DELETE) },
            colors = ButtonDefaults.buttonColors(
                containerColor = if (currentMode == AnnotationMode.DELETE)
                    BrailleLensColors.darkOlive else BrailleLensColors.pastelGreen
            ),
            modifier = Modifier.weight(1f)
        ) {
            Icon(Icons.Default.Delete, contentDescription = "Delete")
            Text("Delete")
        }
    }
}

@Composable
private fun AnnotationCanvas(
    bitmap: Bitmap?,
    boxes: List<DetectedBox>,
    selectedBox: Int?,
    currentMode: AnnotationMode,
    isDrawing: Boolean,
    startPoint: Offset,
    endPoint: Offset,
    currentClass: String,
    onIsDrawingChange: (Boolean) -> Unit,
    onStartPointChange: (Offset) -> Unit,
    onEndPointChange: (Offset) -> Unit,
    onBoxAdd: (DetectedBox) -> Unit,
    onBoxDelete: (Int) -> Unit,
    onBoxSelect: (Int?) -> Unit,
    onBoxUpdate: (Int, DetectedBox) -> Unit,
    annotationStyle: AnnotationStyle
) {
    if (bitmap == null) return

    val density = LocalDensity.current
    val boxTextPaint = remember {
        Paint().apply {
            color = android.graphics.Color.WHITE
            textSize = with(density) { 12.dp.toPx() }
            setShadowLayer(1f, 0f, 0f, android.graphics.Color.BLACK)
        }
    }

    Box(
        modifier = Modifier
            .fillMaxWidth()
            .height(300.dp)
            .padding(vertical = 16.dp)
    ) {
        Canvas(
            modifier = Modifier
                .fillMaxSize()
                .pointerInput(currentMode) {
                    when (currentMode) {
                        AnnotationMode.ADD -> {
                            detectDragGestures(
                                onDragStart = { offset ->
                                    onIsDrawingChange(true)
                                    onStartPointChange(offset)
                                    onEndPointChange(offset)
                                },
                                onDrag = { _, dragAmount ->
                                    onEndPointChange(endPoint + dragAmount)
                                },
                                onDragEnd = {
                                    onIsDrawingChange(false)
                                    if (abs(endPoint.x - startPoint.x) > 10 &&
                                        abs(endPoint.y - startPoint.y) > 10) {

                                        val left = minOf(startPoint.x, endPoint.x)
                                        val top = minOf(startPoint.y, endPoint.y)
                                        val width = abs(endPoint.x - startPoint.x)
                                        val height = abs(endPoint.y - startPoint.y)

                                        // Scale to bitmap coordinates
                                        val scaleX = bitmap.width / size.width
                                        val scaleY = bitmap.height / size.height

                                        // Use class name directly
                                        onBoxAdd(DetectedBox(
                                            x = left * scaleX,
                                            y = top * scaleY,
                                            width = width * scaleX,
                                            height = height * scaleY,
                                            className = currentClass,
                                            classId = BrailleClassIdMapper.getMeaningToClassId(currentClass,
                                                when(gradeSelected) {
                                                    "Grade 1" -> 1
                                                    "Grade 2" -> 2
                                                    else -> 1 // Default to Grade 1 for "Both"
                                                }) ?: -1 // Fallback to -1 if no class ID found
                                        ))
                                    }
                                }
                            )
                        }

                        AnnotationMode.EDIT, AnnotationMode.DELETE -> {
                            detectTapGestures { offset ->
                                val scaleX = bitmap.width / size.width
                                val scaleY = bitmap.height / size.height

                                val tappedIndex = boxes.indexOfFirst { box ->
                                    val scaledX = box.x / scaleX
                                    val scaledY = box.y / scaleY
                                    val scaledWidth = box.width / scaleX
                                    val scaledHeight = box.height / scaleY

                                    offset.x >= scaledX &&
                                            offset.x <= scaledX + scaledWidth &&
                                            offset.y >= scaledY &&
                                            offset.y <= scaledY + scaledHeight
                                }

                                if (tappedIndex >= 0) {
                                    if (currentMode == AnnotationMode.DELETE) {
                                        onBoxDelete(tappedIndex)
                                    } else {
                                        onBoxSelect(if (selectedBox == tappedIndex) null else tappedIndex)
                                    }
                                } else {
                                    onBoxSelect(null)
                                }
                            }
                        }
                        else -> { /* VIEW mode - no interaction */ }
                    }
                }
        ) {
            // Draw the image
            drawContext.canvas.nativeCanvas.drawBitmap(
                bitmap,
                null,
                android.graphics.Rect(0, 0, size.width.toInt(), size.height.toInt()),
                null
            )

            // Draw existing boxes
            boxes.forEachIndexed { index, box ->
                val isSelected = selectedBox == index
                val boxColor = when {
                    isSelected -> annotationStyle.boxColors[AnnotationMode.EDIT]
                    currentMode == AnnotationMode.DELETE -> annotationStyle.boxColors[AnnotationMode.DELETE]
                    else -> annotationStyle.boxColors[AnnotationMode.VIEW]
                } ?: Color.Green

                val strokeWidth = if (isSelected) {
                    annotationStyle.strokeWidth[AnnotationMode.EDIT] ?: 3f
                } else {
                    annotationStyle.strokeWidth[currentMode] ?: 2f
                }

                // Scale box coordinates to canvas size
                val scaleX = size.width / bitmap.width
                val scaleY = size.height / bitmap.height
                val scaledX = box.x * scaleX
                val scaledY = box.y * scaleY
                val scaledWidth = box.width * scaleX
                val scaledHeight = box.height * scaleY

                // Draw box
                drawRect(
                    color = boxColor,
                    topLeft = Offset(scaledX, scaledY),
                    size = Size(scaledWidth, scaledHeight),
                    style = Stroke(width = strokeWidth)
                )

                // Draw class name
                drawContext.canvas.nativeCanvas.drawText(
                    box.className,
                    scaledX,
                    scaledY - 5,
                    boxTextPaint
                )
            }

            // Draw box being created in ADD mode
            if (currentMode == AnnotationMode.ADD && isDrawing) {
                val left = minOf(startPoint.x, endPoint.x)
                val top = minOf(startPoint.y, endPoint.y)
                val width = abs(endPoint.x - startPoint.x)
                val height = abs(endPoint.y - startPoint.y)

                drawRect(
                    color = annotationStyle.boxColors[AnnotationMode.ADD] ?: Color.Blue,
                    topLeft = Offset(left, top),
                    size = Size(width, height),
                    style = Stroke(width = annotationStyle.strokeWidth[AnnotationMode.ADD] ?: 2f)
                )
            }
        }
    }
}